<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>Taio Dev Notes</title>
  <atom:link href="https://dev.taio.app/feed.xml" rel="self" type="application/rss+xml" />
  <link>https://dev.taio.app</link>
  <description>Taio Dev Notes</description>
   
  <item>
    <title><![CDATA[Modern File Apps]]></title>
    <link>https://dev.taio.app/#/editor/files</link>
    <guid isPermaLink="false">https://dev.taio.app/#/editor/files</guid>
    <description><![CDATA[<h1 id="modern-file-apps">Modern File Apps</h1>
<p>Taio's Markdown editor is based on a completely open file system, which provides the basis for cross-app collaboration as well as convenient data transmission, this article will cover some key points to be aware of when developing such an app.</p>
<p>Of course, we are assuming that your goal is to be a good citizen on iOS and contribute to the great ecosystem. If your direction is to create private files or formats, this article won't be very helpful to you.</p>
<h2 id="file-sharing">File Sharing</h2>
<p>Early iOS didn't have the foundation for these great features until Apple released the <a href="https://support.apple.com/en-us/HT206481">Files App</a>, and a bunch of APIs made for file sharing.</p>
<p>The Files app provides a unified interface for shared documents, and developers can expose the <code>Documents</code> directory to the Files app by enabling <code>UIFileSharingEnabled</code> in <code>Info.plist</code>.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;key&gt;</span>UIFileSharingEnabled<span class="kw">&lt;/key&gt;</span>
<span class="kw">&lt;true/&gt;</span></code></pre></div>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_8.png" width="360"></p>
<h2 id="icloud-drive">iCloud Drive</h2>
<p>The <code>Documents</code> directory mentioned above is local. iOS also offers a cloud storage service called <code>iCloud Drive</code>, there're a number of advantages:</p>
<ul>
<li>iCloud account based, no need to create user system, no additional logins for users</li>
<li>Seamless integration with existing file management APIs</li>
<li>Uses the user's iCloud quota, developers don't have to pay for it</li>
</ul>
<p>So, when it comes to creating document synchronization on iOS, iCloud Drive is the way to go.</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_9.png" width="360"></p>
<p>It's also simple to use - just assign an iCloud Container to your app, and then use <a href="https://developer.apple.com/documentation/foundation/filemanager">FileManager</a> to get the path:</p>
<pre class="swift"><code>let url = FileManager.default.url(forUbiquityContainerIdentifier: nil)</code></pre>
<p>Your code needs to handle cases where <code>url</code> is <code>nil</code>, such as when the user is not logged into iCloud, or when the app is not granted iCloud Drive access.</p>
<blockquote>
<p>When permission changes, iOS will post an <a href="https://developer.apple.com/documentation/foundation/nsnotification/name/1407629-nsubiquityidentitydidchange">NSUbiquityIdentityDidChange</a> notification, which can be observed in order to handle interface changes.</p>
</blockquote>
<h2 id="file-provider">File Provider</h2>
<p>The above two solutions provide Files app support for local files and iCloud files respectively, but still cannot handle the case where the file is in other locations. For example, apps that support app extensions may store files in a <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html">Shared Container</a> to make sure both the main app and app extensions can access.</p>
<p>For this case, we can create <a href="https://developer.apple.com/documentation/fileprovider">File Provider Extension</a> to provide files to the Files app.</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_10.png" width="360"></p>
<p>File Provider APIs are fairly straightforward, we recommend taking <a href="https://ish.app/">ish</a> app's <a href="https://github.com/ish-app/ish/tree/master/app/FileProvider">File Provider</a> as a complete example, so we won't go over it here.</p>
<blockquote>
<p>In addition, your app can also support <a href="https://developer.apple.com/documentation/fileproviderui">File Provider UI Extension</a>, which provides custom actions for the Files app.</p>
</blockquote>
<h2 id="document-types">Document types</h2>
<p>Apps can register supported document types in the <code>Info.plist</code> file, for example:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;dict&gt;</span>
  <span class="kw">&lt;key&gt;</span>CFBundleTypeName<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;string&gt;</span>Markdown File<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;key&gt;</span>LSHandlerRank<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;string&gt;</span>Owner<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;key&gt;</span>LSItemContentTypes<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;array&gt;</span>
    <span class="kw">&lt;string&gt;</span>net.daringfireball.markdown<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;/array&gt;</span>
<span class="kw">&lt;/dict&gt;</span></code></pre></div>
<p>This allows you to receive files shared via AirDrop or Share Sheet and then handle them using the methods associated with <code>AppDelegate</code> or <code>SceneDelegate</code> (Multiple Windows).</p>
<p>To make the experience even better, we can support importing folders, not just single files:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;dict&gt;</span>
  <span class="kw">&lt;key&gt;</span>CFBundleTypeName<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;string&gt;</span>Folder<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;key&gt;</span>CFBundleTypeOSTypes<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;array&gt;</span>
    <span class="kw">&lt;string&gt;</span>fold<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;/array&gt;</span>
  <span class="kw">&lt;key&gt;</span>CFBundleTypeRole<span class="kw">&lt;/key</span>
  <span class="er">&lt;string</span><span class="kw">&gt;</span>Viewer<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;key&gt;</span>LSHandlerRank<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;string&gt;</span>Default<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;key&gt;</span>LSItemContentTypes<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;array&gt;</span>
    <span class="kw">&lt;string&gt;</span>public.folder<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;/array&gt;</span>
<span class="er">&lt;</span>/dict&gt;</code></pre></div>
<blockquote>
<p>Taio allows the user to save imported folders to a location.</p>
</blockquote>
<h2 id="exported-type-identifiers">Exported Type Identifiers</h2>
<p>Other than receiving files, apps can also define exclusive file types. For example, Taio's action is essentially a JSON file, which we define as <code>taioactions</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;dict&gt;</span>
  <span class="kw">&lt;key&gt;</span>UTypeConformsTo<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;array&gt;</span>
    <span class="kw">&lt;string&gt;</span>public.json<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;/array&gt;</span>
  <span class="kw">&lt;key&gt;</span>UTTypeDescription<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;string&gt;</span>FileTypeTaioActionsDescription<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;key&gt;</span>UTTypeIdentifier<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;string&gt;</span>app.cyan.taio-actions<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;key&gt;</span>UTTypeTagSpecification<span class="kw">&lt;/key&gt;</span>
  <span class="kw">&lt;dict&gt;</span>
    <span class="kw">&lt;key&gt;</span>public.filename-extension<span class="kw">&lt;/key&gt;</span>
    <span class="kw">&lt;string&gt;</span>taioactions<span class="kw">&lt;/string&gt;</span>
    <span class="kw">&lt;key&gt;</span>public.mime-type<span class="kw">&lt;/key&gt;</span>
    <span class="kw">&lt;string&gt;</span>application/json<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;/dict&gt;</span>
<span class="kw">&lt;/dict&gt;</span></code></pre></div>
<p>Users can see the type description and other apps can register this type as supported:</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_11.png" width="360"></p>
<blockquote>
<p>The above <code>FileTypeTaioActionsDescription</code> is the key to the localizable string.</p>
</blockquote>
<h2 id="uidocumentbrowserviewcontroller">UIDocumentBrowserViewController</h2>
<p>If your app is fully document-based, using a <a href="https://developer.apple.com/documentation/uikit/uidocumentbrowserviewcontroller">UIDocumentBrowserViewController</a> might be a good way to go, and Apple's <a href="https://www.apple.com/iwork/">iWork</a> suite is implemented this way.</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_12.png" width="360"></p>
<p>Taio wasn't implemented like that, because we wanted more UI flexibility, but Apple's <a href="https://developer.apple.com/documentation/uikit/view_controllers/adding_a_document_browser_to_your_app">documentation</a> explicitly states:</p>
<blockquote>
<p>Always assign the document browser as your app's root view controller. Don't place the document browser in a navigation controller, tab bar, or split view, and don't present the document browser modally.</p>
</blockquote>
<p>Also, if you need to open the document picker within the app, you should use <a href="https://developer.apple.com/documentation/uikit/uidocumentpickerviewcontroller">UIDocumentPickerViewController</a> instead of UIDocumentBrowserViewController.</p>
<p>For more information about this part, you can refer to the open source project <a href="https://github.com/louisdh/textor">textor</a>.</p>
<h2 id="open-in-place">Open in Place</h2>
<p>We've mentioned the way to import external files, which creates a copy of the file to your app. <code>Open in Place</code> is the opposite, it allows you to open files from other apps and edit the original file directly.</p>
<p>Just add a key in <code>Info.plist</code> as below:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;key&gt;</span>LSSupportsOpeningDocumentsInPlace<span class="kw">&lt;/key&gt;</span>
<span class="kw">&lt;true/&gt;</span></code></pre></div>
<p>Similar to the document sharing, you need to implement some methods in <code>SceneDelegate</code>, and <code>UIOpenURLContext</code> tells you if it is open-in-place:</p>
<pre class="swift"><code>if context.options.openInPlace {

}</code></pre>
<p>Apps that need to access open-in-place files need to take care of two methods of <a href="https://developer.apple.com/documentation/foundation/url">URL</a>:</p>
<ul>
<li><a href="https://developer.apple.com/documentation/foundation/url/1779698-startaccessingsecurityscopedreso">startAccessingSecurityScopedResource</a></li>
<li><a href="https://developer.apple.com/documentation/foundation/url/1780153-stopaccessingsecurityscopedresou">stopAccessingSecurityScopedResource</a></li>
</ul>
<p>Also, with open-in-place support, long pressing the app icon on iPad will show recently opened files:</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_13.png" width="360"></p>
<blockquote>
<p>The author of the <a href="https://docs.taio.app/#/integration/working-copy">Working Copy</a> app have created a great <a href="https://github.com/palmin/open-in-place">demo project</a> for open-in-place, which is recommended for reference.</p>
</blockquote>
<h2 id="file-bookmarks">File Bookmarks</h2>
<p>The <a href="https://developer.apple.com/documentation/foundation/url/2143023-bookmarkdata">bookmarkData</a> API is not new:</p>
<pre class="swift"><code>let bookmarkData = try url.bookmarkData()</code></pre>
<p>You can use it to store recently opened files, and use <code>resolvingBookmarkData</code> to retrieve the path:</p>
<pre class="swift"><code>let url = try URL(
  resolvingBookmarkData: data,
  bookmarkDataIsStale: &amp;bookmarkIsStale
)</code></pre>
<p>Even if a file is moved, we can still retrieve it correctly. More importantly, file bookmarks can be used to store open-in-place URLs.</p>
<p>Or, store a file or directory opened with <code>UIDocumentPickerViewController</code> so that it can be accessed at any time.</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_14.png" width="360"></p>
<p>Taio supports this feature, so users can edit linked third-party files in Taio at any time.</p>
<h2 id="uidocument">UIDocument</h2>
<p><a href="https://developer.apple.com/documentation/uikit/uidocument">UIDocument</a> provides some wrappers for documents, allowing developers to more easily handle file opening, saving, and state changes, take the above mentioned <a href="https://github.com/louisdh/textor">textor</a> project for some examples, and we want to explain conflict handling a little bit.</p>
<p>Conflict is very common for multi-editor or multi-app editing scenarios. We may edit a file in client A and client B at the same time, and then multiple copies are created on a device.</p>
<p><a href="https://developer.apple.com/documentation/foundation/nsfileversion">NSFileVersion</a> provides a way to get conflict versions:</p>
<pre class="swift"><code>let versions = NSFileVersion.unresolvedConflictVersionsOfItem(at: url)</code></pre>
<p>According to <a href="https://developer.apple.com/library/archive/documentation/DataManagement/Conceptual/DocumentBasedAppPGiOS/ResolveVersionConflicts/ResolveVersionConflicts.html">Apple's documentation</a>, the app can decide a strategy for conflicts resolving, such as always using the latest version. However, Taio is a text editor, we believe it would be a better idea to let the user compare the differences:</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_15.png" width="360"></p>
<p>This way, users are always confident about what have changed, the same logic is used for Taio's local history feature.</p>
<h2 id="textbundle">TextBundle</h2>
<p>The <a href="http://textbundle.org/">TextBundle</a> format defines as an open specification to standardize file sharing across apps.</p>
<p>A TextBundle directory contains metadata and a text file, as well as an <code>assets</code> folder for images.</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_16.png" width="360"></p>
<p>With this format, documents and their referenced resources can be packaged into a single file and shared across apps that support TextBundle.</p>
<p>You can refer to the <a href="http://textbundle.org/spec/">specification</a> of TextBundle to learn how to implement it, or take a look the <a href="https://github.com/shinyfrog/TextBundle">TextBundle</a> open source project.</p>
<blockquote>
<p>The above project is also an example of <a href="https://developer.apple.com/documentation/foundation/filewrapper">FileWrapper</a>.</p>
</blockquote>
<h2 id="trashing">Trashing</h2>
<p>Instead of removing files directly, apps can also use the <code>trashItem</code> method of FileManager:</p>
<pre class="swift"><code>try FileManager.default.trashItem(at: url, resultingItemURL: &amp;resultingURL)</code></pre>
<p>Files removed by this method will be moved to the <code>Recently Deleted</code> folder in the Files app and can be restored by the user. This method essentially creates a <code>.Trash</code> hidden directory for the file and will automatically handle naming issues.</p>
<h2 id="more-content">More Content</h2>
<p>As we can see, it's not easy to make a file based app great, Taio has done a lot of work, and there's lots of room to improve.</p>
<p>Apple offers a lot of tutorials for document apps, such as <a href="https://developer.apple.com/document-based-apps/">Document Based Apps</a>, as well as a series of related sessions presented at WWDC that are recommended for further exploring.</p>
<p>Last but not least, thanks to all the third-party content referenced in this article for their contributions to the ecosystem.</p>
<blockquote>
<p>[!NOTE] Dec 24, 2020</p>
</blockquote>]]></description>
    <pubDate>Fri, 25 Dec 2020 10:30:56 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Editor Toolbar Experience]]></title>
    <link>https://dev.taio.app/#/editor/toolbar</link>
    <guid isPermaLink="false">https://dev.taio.app/#/editor/toolbar</guid>
    <description><![CDATA[<h1 id="editor-toolbar-experience">Editor Toolbar Experience</h1>
<p>For text editing, a well designed toolbar is essential, especially when there is no hardware keyboard connected. Taio offers a handy toolbar that can be used to type symbols, or to quickly complete some tasks:</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_1.png" width="360" /></p>
<p>This article takes less than ten minutes to read, and we hope there are parts that will be useful to you.</p>
<h2 id="inputaccessoryview">inputAccessoryView</h2>
<p>To implement such a toolbar on iOS, we mostly use <code>inputAccessoryView</code> instead of listening to the keyboard frame changes:</p>
<pre class="swift"><code>textView.inputAccessoryView = UIView(...)</code></pre>
<p>You can implement this toolbar using any <code>UIView</code>, but that's not the recommended way. To implement a native-style toolbar like many 1st-party apps by Apple, we should use <code>UIInputView</code> and provide it with the keyboard style:</p>
<pre class="swift"><code>textView.inputAccessoryView = UIInputView(... , inputViewStyle: .keyboard)</code></pre>
<p>iOS will automatically provide you with the exact same style as the keyboard background, without having to manage its color yourself.</p>
<h2 id="safe-area">Safe Area</h2>
<p>When an external keyboard is being used, users can optionally hide the soft keyboard. In that case, you should take into account the bottom safe area, like this:</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_2.png" width="360" /></p>
<p>Instead of having the <code>Home Indicator</code> cover your toolbar.</p>
<h2 id="inputview">inputView</h2>
<p>When necessary, we may need to provide a &quot;secondary keyboard&quot; for the TextView, such as the symbol panel and snippet panel in Taio:</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_3.png" width="360" /></p>
<p>This is achieved by overriding the <code>TextView.inputView</code> with:</p>
<pre class="swift"><code>textView.inputView = UIView(...)
textView.reloadInputViews()</code></pre>
<p>It is worth noting that there is a very small issue here that happens when the user is using some input methods (E.g. Pinyin for Chinese).</p>
<p>When there are some words in the selection area of the input method, switch the keyboard to the interface implemented by <code>inputView</code> and then switch back again. At this point, the selection area will suddenly disappear and the user feels a <strong>sudden</strong> change in the height of the keyboard.</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_4.png" width="720" /></p>
<p>This issue appears in the vast majority of apps, including 1st-party apps by Apple, but we didn't let it go.</p>
<p>We noticed that <strong>after the user moved the cursor, the selection would suddenly come back</strong>. So we rewrote the <code>setInputView</code> method, when an inputView change is detected, we do:</p>
<ul>
<li>Move the cursor programmatically (direction doesn't matter)</li>
<li>Move it back</li>
</ul>
<p>With this little trick, the user doesn't feel any sudden changes and everything is perfect.</p>
<h2 id="input-clicks">Input Clicks</h2>
<p>Since the actions take place in the extended area of the keyboard, it's natural to add keyboard sounds (which the user can choose to turn off) to these actions.</p>
<p><code>UIDevice</code> has a <code>playInputClick</code> method, which can be used by implementing <code>enableInputClicksWhenVisible</code>.</p>
<p>But there is a more simple (and stupid) approach:</p>
<pre class="swift"><code>AudioServicesPlaySystemSound(1104)</code></pre>
<p><em>It's pure magic.</em></p>
<h2 id="pointer-interactions">Pointer Interactions</h2>
<p>Since our app expects the user to use it on an iPad with a magic keyboard connected, it is extremely important that the buttons on the keyboard support the <code>Hover</code> effect of the trackpad.</p>
<p>Instead of saying too much here, you can find many WWDC sessions on the Apple developer website.</p>
<p>We strongly recommend: <a href="https://developer.apple.com/videos/play/wwdc2020/10640/">Design for the iPadOS pointer</a>.</p>
<h2 id="better-scrolling">Better Scrolling</h2>
<p>We use a standard <code>UIScrollView</code> for the toolbar scrolling, it works great, but we wanted to optimize the experience even further.</p>
<p>In short, users will expect every step to be accurate, rather than scrolling to an unexpected position, which is important to improve user confidence.</p>
<p>If your scrollView has a fixed page size, you can simply achieve this using the <code>paging</code> feature:</p>
<pre class="swift"><code>scrollView.isPagingEnabled = true</code></pre>
<p>But as you may have noticed, Taio's toolbar groups buttons, so we'll have to implement our own paging algorithm.</p>
<p>Our first step is to increase the deceleration rate of the scrollView so that scrolling can stop quicker:</p>
<pre class="swift"><code>scrollView.decelerationRate = .fast</code></pre>
<p>Just by doing this step, you'll feel a big improvement in the toolbar because it won't scroll like crazy anymore. After that, we use the following delegate method to fix up the target position:</p>
<pre class="swift"><code>func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;) {

}</code></pre>
<p>You need to figure out for yourself where is the best position to stop. For Taio, we chose to stop exactly where a button group starts.</p>
<blockquote>
<p>You can check the <code>velocity</code> so that the user can scroll slowly and stop at any position.</p>
</blockquote>
<h2 id="cursor-movement">Cursor Movement</h2>
<p>As you may have noticed, Taio's toolbar provides a feature that moves the cursor position forward or backward with a single tap.</p>
<p>But that's not enough; the user expects the cursor to move continuously and progressively faster when it's held down. Just like pressing and holding the delete key, it makes users happy.</p>
<p>After adjusting the way the movement speed changes so many times, we finally got an approach very close to the delete key by setting a <code>Timer</code> with the <code>InputClick</code> effect mentioned above.</p>
<h2 id="optimize-for-ipad">Optimize for iPad</h2>
<p>As we mentioned before, <code>inputView</code> is great for extending the keyboard, but it cannot be applied to an iPad with an external keyboard, because the keyboard will possibly be hidden.</p>
<p>In this case, we'll use a <code>Popover</code> instead, like this:</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_5.png" width="360" /></p>
<blockquote>
<p>It's important that you should not check whether or not it's an iPad to determine what environment the user is in. Because iPad can look pretty much like iPhone when using split views, and there's floating mode for iPad keyboard.</p>
</blockquote>
<h2 id="standard-edit-actions">Standard Edit Actions</h2>
<p>Since Markdown supports text styles bold and italic, it's natural to control the formatting using <code>UIMenuController</code>, which can be done with <code>UIResponderStandardEditActions</code>:</p>
<pre class="swift"><code>override func toggleBoldface(_ sender: Any?) {

}

override func toggleItalics(_ sender: Any?) {

}

override func toggleUnderline(_ sender: Any?) {

}</code></pre>
<p>iOS does all the work for you, you just need to link your existing implementation to these methods.</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_6.png" width="360" /></p>
<p>As a side effect, there is now a redundant BIU button group on iPad, which is a duplicate of the one on our toolbar.</p>
<p><img src="https://github.com/cyanzhong/dev.taio.app/raw/master/docs/editor/assets/IMG_7.png" width="360" /></p>
<p>Not a big problem, let's get rid of it by overriding the <code>inputAssistantItem</code> with:</p>
<pre class="swift"><code>view.inputAssistantItem.trailingBarButtonGroups = []</code></pre>
<p>Of course, you can also set them to other buttons if you feel it's necessary.</p>
<h2 id="more-content">More Content</h2>
<p>As we said before, text editing is never easy and we have done a lot of work for it.</p>
<p>This article is only a small part of it, stay tuned for more interesting content.</p>
<blockquote>
<p>[!NOTE] Dec 16, 2020</p>
</blockquote>]]></description>
    <pubDate>Thu, 24 Dec 2020 22:26:17 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Hello, World!]]></title>
    <link>https://dev.taio.app/#/README</link>
    <guid isPermaLink="false">https://dev.taio.app/#/README</guid>
    <description><![CDATA[<h1 id="hello-world">Hello, World!</h1>
<p>We are the team who build the <a href="https://taio.app">Taio</a> app.</p>
<p>In the past few years, we have learned a lot from the community, and it's time to give back.</p>
<p>We are going to share every secret about Taio, including development skills, lesson learned, design thinking, and more.</p>
<p>Stay tuned.</p>
<h2 id="contact-us">Contact Us</h2>
<p>Feel free to reach us out:</p>
<ul>
<li>Email: <a href="mailto:hi@taio.app">hi@taio.app</a></li>
<li>Twitter: <a href="https://twitter.com/TaioApp" class="uri">https://twitter.com/TaioApp</a></li>
</ul>]]></description>
    <pubDate>Wed, 16 Dec 2020 14:18:54 +0800</pubDate>
  </item>
  
</channel>
</rss>
